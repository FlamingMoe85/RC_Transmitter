
Extern_DigAna_Source.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002d2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  000002d2  00000366  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000012  00800062  00800062  00000368  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00000368  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000145  00000000  00000000  00000388  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000309  00000000  00000000  000004cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000187  00000000  00000000  000007d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000002f9  00000000  00000000  0000095d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000c0  00000000  00000000  00000c58  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000015f  00000000  00000000  00000d18  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000001e  00000000  00000000  00000e77  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	0f c1       	rjmp	.+542    	; 0x222 <__vector_1>
   4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
   c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	11 c1       	rjmp	.+546    	; 0x23a <__vector_11>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	43 c1       	rjmp	.+646    	; 0x2a2 <__vector_13>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e2 ed       	ldi	r30, 0xD2	; 210
  3a:	f2 e0       	ldi	r31, 0x02	; 2
  3c:	02 c0       	rjmp	.+4      	; 0x42 <.do_copy_data_start>

0000003e <.do_copy_data_loop>:
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0

00000042 <.do_copy_data_start>:
  42:	a2 36       	cpi	r26, 0x62	; 98
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <.do_copy_data_loop>

00000048 <__do_clear_bss>:
  48:	10 e0       	ldi	r17, 0x00	; 0
  4a:	a2 e6       	ldi	r26, 0x62	; 98
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	a4 37       	cpi	r26, 0x74	; 116
  54:	b1 07       	cpc	r27, r17
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	a0 d0       	rcall	.+320    	; 0x19a <main>
  5a:	39 c1       	rjmp	.+626    	; 0x2ce <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <SendByteCntr>:

char tmp, switchBits;

void SendByteCntr(char val)
{ 
	while ( !( UCSRA & (1<<UDRE)) );
  5e:	5d 9b       	sbis	0x0b, 5	; 11
  60:	fe cf       	rjmp	.-4      	; 0x5e <SendByteCntr>
	UDR = val;
  62:	8c b9       	out	0x0c, r24	; 12
	while ( !( UCSRA & (1<<UDRE)) );
  64:	5d 9b       	sbis	0x0b, 5	; 11
  66:	fe cf       	rjmp	.-4      	; 0x64 <SendByteCntr+0x6>

} 
  68:	08 95       	ret

0000006a <GetTick>:

char GetTick()
{
	static unsigned int c1 = 0, c2 = 0;
	c1++;
  6a:	80 91 6e 00 	lds	r24, 0x006E
  6e:	90 91 6f 00 	lds	r25, 0x006F
  72:	01 96       	adiw	r24, 0x01	; 1
  74:	90 93 6f 00 	sts	0x006F, r25
  78:	80 93 6e 00 	sts	0x006E, r24
	if(c1 >= 100)
  7c:	84 36       	cpi	r24, 0x64	; 100
  7e:	91 05       	cpc	r25, r1
  80:	68 f0       	brcs	.+26     	; 0x9c <GetTick+0x32>
	{
		c1 = 0;
  82:	10 92 6f 00 	sts	0x006F, r1
  86:	10 92 6e 00 	sts	0x006E, r1
		c2++; 
  8a:	80 91 6c 00 	lds	r24, 0x006C
  8e:	90 91 6d 00 	lds	r25, 0x006D
  92:	01 96       	adiw	r24, 0x01	; 1
  94:	90 93 6d 00 	sts	0x006D, r25
  98:	80 93 6c 00 	sts	0x006C, r24
	} 
	if(c2 >= 5)
  9c:	80 91 6c 00 	lds	r24, 0x006C
  a0:	90 91 6d 00 	lds	r25, 0x006D
  a4:	05 97       	sbiw	r24, 0x05	; 5
  a6:	10 f4       	brcc	.+4      	; 0xac <GetTick+0x42>
  a8:	80 e0       	ldi	r24, 0x00	; 0
  aa:	08 95       	ret
	{
		c2 = 0; 
  ac:	10 92 6d 00 	sts	0x006D, r1
  b0:	10 92 6c 00 	sts	0x006C, r1
  b4:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	return 0;
}
  b6:	08 95       	ret

000000b8 <SignalCapa>:

void SignalCapa(char sig)
{
	if(sig == RX_FREE)
  b8:	88 23       	and	r24, r24
  ba:	21 f4       	brne	.+8      	; 0xc4 <SignalCapa+0xc>
	{
		
		freeState = 1;
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	80 93 6b 00 	sts	0x006B, r24
  c2:	08 95       	ret
		//DDRD &= ~(0b00001000);  
		}
	else
	{ 
		DDRD |= 0b00001000; 
  c4:	8b 9a       	sbi	0x11, 3	; 17
  c6:	08 95       	ret

000000c8 <GET_RX_STATE>:
	}
}

char GET_RX_STATE()
{ 
	if((PIND & 0b00010000) == 16) return RX_FREE;
  c8:	80 b3       	in	r24, 0x10	; 16
  ca:	82 95       	swap	r24
  cc:	8f 70       	andi	r24, 0x0F	; 15
  ce:	80 95       	com	r24
	else return RX_BUSY;
}
  d0:	81 70       	andi	r24, 0x01	; 1
  d2:	08 95       	ret

000000d4 <UartRx>:

void UartRx()
{
char tmpChar;
	
rxFlag = 0;
  d4:	10 92 63 00 	sts	0x0063, r1

 	
	tmpChar = UDR;
  d8:	2c b1       	in	r18, 0x0c	; 12
	byteArr[head++] = tmpChar;
  da:	80 91 67 00 	lds	r24, 0x0067
  de:	90 91 68 00 	lds	r25, 0x0068
  e2:	fc 01       	movw	r30, r24
  e4:	ef 58       	subi	r30, 0x8F	; 143
  e6:	ff 4f       	sbci	r31, 0xFF	; 255
  e8:	20 83       	st	Z, r18
  ea:	01 96       	adiw	r24, 0x01	; 1
  ec:	90 93 68 00 	sts	0x0068, r25
  f0:	80 93 67 00 	sts	0x0067, r24
	
	if(head == 2) head = 0;
  f4:	80 91 67 00 	lds	r24, 0x0067
  f8:	90 91 68 00 	lds	r25, 0x0068
  fc:	02 97       	sbiw	r24, 0x02	; 2
  fe:	21 f4       	brne	.+8      	; 0x108 <UartRx+0x34>
 100:	10 92 68 00 	sts	0x0068, r1
 104:	10 92 67 00 	sts	0x0067, r1
	byteCntr++;
 108:	80 91 62 00 	lds	r24, 0x0062
 10c:	8f 5f       	subi	r24, 0xFF	; 255
 10e:	80 93 62 00 	sts	0x0062, r24
	if((UCSRA & 0b10000000) == 128)
 112:	5f 9b       	sbis	0x0b, 7	; 11
 114:	1d c0       	rjmp	.+58     	; 0x150 <UartRx+0x7c>
	{ 
		tmpChar = UDR;
 116:	2c b1       	in	r18, 0x0c	; 12
		byteArr[head++] = tmpChar; 
 118:	80 91 67 00 	lds	r24, 0x0067
 11c:	90 91 68 00 	lds	r25, 0x0068
 120:	fc 01       	movw	r30, r24
 122:	ef 58       	subi	r30, 0x8F	; 143
 124:	ff 4f       	sbci	r31, 0xFF	; 255
 126:	20 83       	st	Z, r18
 128:	01 96       	adiw	r24, 0x01	; 1
 12a:	90 93 68 00 	sts	0x0068, r25
 12e:	80 93 67 00 	sts	0x0067, r24
		if(head == 2) head = 0;
 132:	80 91 67 00 	lds	r24, 0x0067
 136:	90 91 68 00 	lds	r25, 0x0068
 13a:	02 97       	sbiw	r24, 0x02	; 2
 13c:	21 f4       	brne	.+8      	; 0x146 <UartRx+0x72>
 13e:	10 92 68 00 	sts	0x0068, r1
 142:	10 92 67 00 	sts	0x0067, r1
		byteCntr++;
 146:	80 91 62 00 	lds	r24, 0x0062
 14a:	8f 5f       	subi	r24, 0xFF	; 255
 14c:	80 93 62 00 	sts	0x0062, r24
 150:	08 95       	ret

00000152 <Send>:

void Send()
{
	

	if(byteCntr > 0)
 152:	80 91 62 00 	lds	r24, 0x0062
 156:	88 23       	and	r24, r24
 158:	a9 f0       	breq	.+42     	; 0x184 <Send+0x32>
	}
}

char GET_RX_STATE()
{ 
	if((PIND & 0b00010000) == 16) return RX_FREE;
 15a:	84 9b       	sbis	0x10, 4	; 16
 15c:	13 c0       	rjmp	.+38     	; 0x184 <Send+0x32>
 	{
	
 		if(GET_RX_STATE() == RX_FREE)
 		{
			
PORTC |= 0b00100000;
 15e:	ad 9a       	sbi	0x15, 5	; 21
			 	UDR = switchBits;//byteArr[tail++];
 160:	80 91 73 00 	lds	r24, 0x0073
 164:	8c b9       	out	0x0c, r24	; 12

		 	if(tail == 2) tail = 0;
 166:	80 91 69 00 	lds	r24, 0x0069
 16a:	90 91 6a 00 	lds	r25, 0x006A
 16e:	02 97       	sbiw	r24, 0x02	; 2
 170:	21 f4       	brne	.+8      	; 0x17a <Send+0x28>
 172:	10 92 6a 00 	sts	0x006A, r1
 176:	10 92 69 00 	sts	0x0069, r1
			byteCntr--; 
 17a:	80 91 62 00 	lds	r24, 0x0062
 17e:	81 50       	subi	r24, 0x01	; 1
 180:	80 93 62 00 	sts	0x0062, r24
		 }  
		 
 	}  
	if(byteCntr == 0)SignalCapa(RX_FREE);
 184:	80 91 62 00 	lds	r24, 0x0062
 188:	88 23       	and	r24, r24
 18a:	19 f4       	brne	.+6      	; 0x192 <Send+0x40>
void SignalCapa(char sig)
{
	if(sig == RX_FREE)
	{
		
		freeState = 1;
 18c:	81 e0       	ldi	r24, 0x01	; 1
 18e:	80 93 6b 00 	sts	0x006B, r24
 192:	08 95       	ret

00000194 <UartTx>:
	if(byteCntr == 0)SignalCapa(RX_FREE);
}

void UartTx()
{
txFlag = 0;
 194:	10 92 64 00 	sts	0x0064, r1

	//void Send();
}
 198:	08 95       	ret

0000019a <main>:
int main(void)
{ 


/* Set baud rate  for 9600 Baud*/
UBRRH = (unsigned char)(0);
 19a:	10 bc       	out	0x20, r1	; 32
UBRRL = (unsigned char)52;
 19c:	84 e3       	ldi	r24, 0x34	; 52
 19e:	89 b9       	out	0x09, r24	; 9
/* Enable receiver and transmitter */
UCSRB = (1<<7)|(1<<6)|(1<<RXEN)|(1<<TXEN);//
 1a0:	88 ed       	ldi	r24, 0xD8	; 216
 1a2:	8a b9       	out	0x0a, r24	; 10
//UCSRB = (1<<RXEN);
/* Set frame format: 8data, 2stop bit */
UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);
 1a4:	8e e8       	ldi	r24, 0x8E	; 142
 1a6:	80 bd       	out	0x20, r24	; 32
DDRD = 0b00000010; 
 1a8:	92 e0       	ldi	r25, 0x02	; 2
 1aa:	91 bb       	out	0x11, r25	; 17

PORTD |= 0b11100000; 
 1ac:	82 b3       	in	r24, 0x12	; 18
 1ae:	80 6e       	ori	r24, 0xE0	; 224
 1b0:	82 bb       	out	0x12, r24	; 18
PORTB |= 0b11000001;
 1b2:	88 b3       	in	r24, 0x18	; 24
 1b4:	81 6c       	ori	r24, 0xC1	; 193
 1b6:	88 bb       	out	0x18, r24	; 24

MCUCR = 0b00000010;
 1b8:	95 bf       	out	0x35, r25	; 53
GICR = 0b01000000;
 1ba:	80 e4       	ldi	r24, 0x40	; 64
 1bc:	8b bf       	out	0x3b, r24	; 59
GIFR = 0b01000000;
 1be:	8a bf       	out	0x3a, r24	; 58
DDRC = 0b00100000;
 1c0:	80 e2       	ldi	r24, 0x20	; 32
 1c2:	84 bb       	out	0x14, r24	; 20
sei(); 
 1c4:	78 94       	sei


while(1)
{ 
	switchBits = ((PINB & 0b11000000) ^ 0b11000000) >> 6;
 1c6:	26 b3       	in	r18, 0x16	; 22

/**/
	tmp = ((PINB & 0b00000001) ^ 0b00000001) << 5;
 1c8:	b0 9b       	sbis	0x16, 0	; 22
 1ca:	02 c0       	rjmp	.+4      	; 0x1d0 <main+0x36>
 1cc:	40 e0       	ldi	r20, 0x00	; 0
 1ce:	01 c0       	rjmp	.+2      	; 0x1d2 <main+0x38>
 1d0:	40 e2       	ldi	r20, 0x20	; 32
	switchBits |= tmp;

	tmp = ((PIND & 0b11100000) ^ 0b11100000) >> 3;
 1d2:	80 b3       	in	r24, 0x10	; 16
 1d4:	90 e0       	ldi	r25, 0x00	; 0
 1d6:	80 95       	com	r24
 1d8:	90 95       	com	r25
 1da:	80 7e       	andi	r24, 0xE0	; 224
 1dc:	90 70       	andi	r25, 0x00	; 0
 1de:	33 e0       	ldi	r19, 0x03	; 3
 1e0:	95 95       	asr	r25
 1e2:	87 95       	ror	r24
 1e4:	3a 95       	dec	r19
 1e6:	e1 f7       	brne	.-8      	; 0x1e0 <main+0x46>
 1e8:	80 93 70 00 	sts	0x0070, r24
{ 
	switchBits = ((PINB & 0b11000000) ^ 0b11000000) >> 6;

/**/
	tmp = ((PINB & 0b00000001) ^ 0b00000001) << 5;
	switchBits |= tmp;
 1ec:	30 e0       	ldi	r19, 0x00	; 0
 1ee:	20 95       	com	r18
 1f0:	30 95       	com	r19
 1f2:	20 7c       	andi	r18, 0xC0	; 192
 1f4:	30 70       	andi	r19, 0x00	; 0
 1f6:	96 e0       	ldi	r25, 0x06	; 6
 1f8:	35 95       	asr	r19
 1fa:	27 95       	ror	r18
 1fc:	9a 95       	dec	r25
 1fe:	e1 f7       	brne	.-8      	; 0x1f8 <main+0x5e>
 200:	82 2b       	or	r24, r18

	tmp = ((PIND & 0b11100000) ^ 0b11100000) >> 3;
	switchBits |= tmp;
 202:	84 2b       	or	r24, r20
 204:	80 93 73 00 	sts	0x0073, r24
	

	Send();  
 208:	a4 df       	rcall	.-184    	; 0x152 <Send>
			freeState = 0;
			DDRD &= ~(0b00001000);
		}
	}*/

	if(rxFlag == 1)UartRx();
 20a:	80 91 63 00 	lds	r24, 0x0063
 20e:	81 30       	cpi	r24, 0x01	; 1
 210:	09 f4       	brne	.+2      	; 0x214 <main+0x7a>
 212:	60 df       	rcall	.-320    	; 0xd4 <UartRx>
	if(txFlag == 1)UartTx();
 214:	80 91 64 00 	lds	r24, 0x0064
 218:	81 30       	cpi	r24, 0x01	; 1
 21a:	a9 f6       	brne	.-86     	; 0x1c6 <main+0x2c>
	if(byteCntr == 0)SignalCapa(RX_FREE);
}

void UartTx()
{
txFlag = 0;
 21c:	10 92 64 00 	sts	0x0064, r1
 220:	d2 cf       	rjmp	.-92     	; 0x1c6 <main+0x2c>

00000222 <__vector_1>:
}
}//main


SIGNAL (INT0_vect)
{
 222:	1f 92       	push	r1
 224:	0f 92       	push	r0
 226:	0f b6       	in	r0, 0x3f	; 63
 228:	0f 92       	push	r0
 22a:	11 24       	eor	r1, r1
	DDRD |= 0b00001000;
 22c:	8b 9a       	sbi	0x11, 3	; 17
	GICR = 0b00000000;
 22e:	1b be       	out	0x3b, r1	; 59

}
 230:	0f 90       	pop	r0
 232:	0f be       	out	0x3f, r0	; 63
 234:	0f 90       	pop	r0
 236:	1f 90       	pop	r1
 238:	18 95       	reti

0000023a <__vector_11>:

SIGNAL (USART_RXC_vect)//TIMER1_COMPA_vect) 
{ 
 23a:	1f 92       	push	r1
 23c:	0f 92       	push	r0
 23e:	0f b6       	in	r0, 0x3f	; 63
 240:	0f 92       	push	r0
 242:	11 24       	eor	r1, r1
 244:	2f 93       	push	r18
 246:	8f 93       	push	r24
 248:	9f 93       	push	r25
 24a:	ef 93       	push	r30
 24c:	ff 93       	push	r31
	//SignalCapa(RX_BUSY); 
	DDRD |= 0b00001000;
 24e:	8b 9a       	sbi	0x11, 3	; 17
	//UartRx();
	
rxFlag = 0;
 250:	10 92 63 00 	sts	0x0063, r1
 
	byteArr[head++] = UDR;
 254:	80 91 67 00 	lds	r24, 0x0067
 258:	90 91 68 00 	lds	r25, 0x0068
 25c:	2c b1       	in	r18, 0x0c	; 12
 25e:	fc 01       	movw	r30, r24
 260:	ef 58       	subi	r30, 0x8F	; 143
 262:	ff 4f       	sbci	r31, 0xFF	; 255
 264:	20 83       	st	Z, r18
 266:	01 96       	adiw	r24, 0x01	; 1
 268:	90 93 68 00 	sts	0x0068, r25
 26c:	80 93 67 00 	sts	0x0067, r24
	
	if(head == 2) head = 0;
 270:	80 91 67 00 	lds	r24, 0x0067
 274:	90 91 68 00 	lds	r25, 0x0068
 278:	02 97       	sbiw	r24, 0x02	; 2
 27a:	21 f4       	brne	.+8      	; 0x284 <__vector_11+0x4a>
 27c:	10 92 68 00 	sts	0x0068, r1
 280:	10 92 67 00 	sts	0x0067, r1
	byteCntr++;
 284:	80 91 62 00 	lds	r24, 0x0062
 288:	8f 5f       	subi	r24, 0xFF	; 255
 28a:	80 93 62 00 	sts	0x0062, r24
	{ 
		byteArr[head++] = UDR; 
		if(head == 2) head = 0;
		byteCntr++;
    }  */
}
 28e:	ff 91       	pop	r31
 290:	ef 91       	pop	r30
 292:	9f 91       	pop	r25
 294:	8f 91       	pop	r24
 296:	2f 91       	pop	r18
 298:	0f 90       	pop	r0
 29a:	0f be       	out	0x3f, r0	; 63
 29c:	0f 90       	pop	r0
 29e:	1f 90       	pop	r1
 2a0:	18 95       	reti

000002a2 <__vector_13>:

SIGNAL (USART_TXC_vect)//TIMER1_COMPA_vect) 
{ 
 2a2:	1f 92       	push	r1
 2a4:	0f 92       	push	r0
 2a6:	0f b6       	in	r0, 0x3f	; 63
 2a8:	0f 92       	push	r0
 2aa:	11 24       	eor	r1, r1
 2ac:	8f 93       	push	r24
if(freeState == 1)
 2ae:	80 91 6b 00 	lds	r24, 0x006B
 2b2:	81 30       	cpi	r24, 0x01	; 1
 2b4:	31 f4       	brne	.+12     	; 0x2c2 <__vector_13+0x20>
{
	GIFR = 0b01000000;
 2b6:	80 e4       	ldi	r24, 0x40	; 64
 2b8:	8a bf       	out	0x3a, r24	; 58
		GICR = 0b01000000;
 2ba:	8b bf       	out	0x3b, r24	; 59
		freeState = 0;
 2bc:	10 92 6b 00 	sts	0x006B, r1
DDRD &= ~(0b00001000); 
 2c0:	8b 98       	cbi	0x11, 3	; 17
		}
}
 2c2:	8f 91       	pop	r24
 2c4:	0f 90       	pop	r0
 2c6:	0f be       	out	0x3f, r0	; 63
 2c8:	0f 90       	pop	r0
 2ca:	1f 90       	pop	r1
 2cc:	18 95       	reti

000002ce <_exit>:
 2ce:	f8 94       	cli

000002d0 <__stop_program>:
 2d0:	ff cf       	rjmp	.-2      	; 0x2d0 <__stop_program>
